(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{433:function(t,e,a){"use strict";a.r(e);var n=a(2),r=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"什么是spring框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring框架"}},[t._v("#")]),t._v(" 什么是Spring框架?")]),t._v(" "),e("h3",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),e("p",[t._v("一个容器，整合其他框架的框架，核心AOC(控制反转)和AOP(面向切面编程)，各个领域提供解决方案。")]),t._v(" "),e("p",[t._v("主要作用:")]),t._v(" "),e("ol",[e("li",[t._v("为代码解耦，降低代码间的耦合度。让对象和对象，模块和模块之间的关系不是代码关联，而是通过配置来说明。即在Spring中说明关系。理解：当某个部分坏了，不会影响了其他部分。")]),t._v(" "),e("li",[t._v("使用AOC控制反转来降低业务对象的耦合度，将对象的创建，赋值交给容器。")])]),t._v(" "),e("h3",{attrs:{id:"优点-特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点-特点"}},[t._v("#")]),t._v(" 优点 特点")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("轻量级")])]),t._v(" "),e("li",[e("p",[t._v("面向接口编程")])]),t._v(" "),e("li",[e("p",[t._v("面向切面编程AOP")]),t._v(" "),e("p",[t._v("将公共的代码独立开发，需要的时候反织回去，底层原理是动态代理")])]),t._v(" "),e("li",[e("p",[t._v("整合其他框架")])])]),t._v(" "),e("h3",{attrs:{id:"控制反转aoc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#控制反转aoc"}},[t._v("#")]),t._v(" 控制反转AOC")]),t._v(" "),e("p",[t._v("一种思想，由Spring容器进行对象的创建和依赖注入，程序员使用时直接取出使用")]),t._v(" "),e("p",[t._v("正转：程序员来控制。")]),t._v(" "),e("p",[t._v("反转:Spring容器来控制，程序员直接取出使用。")]),t._v(" "),e("h2",{attrs:{id:"spring"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[t._v("#")]),t._v(" Spring")]),t._v(" "),e("h3",{attrs:{id:"控制反转ioc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#控制反转ioc"}},[t._v("#")]),t._v(" 控制反转IOC")]),t._v(" "),e("h4",{attrs:{id:"开发步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开发步骤"}},[t._v("#")]),t._v(" 开发步骤")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("创建一个空项目")])]),t._v(" "),e("li",[e("p",[t._v("创建一个quickstart的maven模块,补全目录结构")])]),t._v(" "),e("li",[e("p",[t._v("配置xml文件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    注入spring依赖\n    <dependency>\n      <groupId>org.springframework</groupId>\n      <artifactId>spring-context</artifactId>\n      <version>5.2.5.RELEASE</version>\n    </dependency>\n    资源指定\n    <resources>\n      <resource>\n        <directory>src/main/java</directory>\n        <includes>\n          <include>**/*.xml</include>\n          <include>**/*.properties</include>\n        </includes>\n      </resource>\n      <resource>\n        <directory>src/main/resources</directory>\n        <includes>\n          <include>**/*.xml</include>\n          <include>**/*.properties</include>\n        </includes>\n      </resource>\n    </resources>\n")])])])]),t._v(" "),e("li",[e("p",[t._v("编写applicationContext.xml文件")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n 代码内容完成对象的创建和依赖注入      \n       \n</beans>\n')])])])])]),t._v(" "),e("h3",{attrs:{id:"spring创建对象和依赖注入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring创建对象和依赖注入"}},[t._v("#")]),t._v(" Spring创建对象和依赖注入")]),t._v(" "),e("p",[t._v("创建对象：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<bean id="school" class="xyz.zch1337.pojo2.School"></bean>\n')])])]),e("p",[t._v("注入:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('    setter方法注入\n    <bean id="school" class="xyz.zch1337.pojo2.School">\n        <property name="name" value="普通大学"></property>\n        <property name="address" value="四川"></property>\n    </bean>\n    <bean id="stu" class="xyz.zch1337.pojo.Student">\n        <property name="name" value="zch"></property>\n        <property name="age" value="15"></property>\n        <property name="school">\n            <ref bean="school"></ref>\n        </property>\n    </bean>\n    构造方法注入\n    构造方法的参数名称注入\n    <bean id="school" class="xyz.zch1337.pojo3.School">\n        <constructor-arg name="name" value="1123">\t\t\t         </constructor-arg>\n        <constructor-arg name="address" value="1123">\t\t\t\t</constructor-arg>\n    </bean>    \n    构造方法的下标注入\n    <bean id="student" class="xyz.zch1337.pojo3.Student">\n        <constructor-arg index="0" value="张三">\t\t  \t\t\t</constructor-arg>\n        <constructor-arg index="1" value="123">\t\t\t     \t\t </constructor-arg>\n        <constructor-arg index="2" ref="school">\t   \t\t\t\t</constructor-arg>\n    </bean>\n    构造方法的默认顺序\n    <bean id="student1" class="xyz.zch1337.pojo3.Student">\n        <constructor-arg value="张三"></constructor-arg>\n        <constructor-arg value="123"></constructor-arg>\n        <constructor-arg ref="school"></constructor-arg>\n    </bean>\n')])])]),e("p",[t._v("使用对象:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('创建容器:\nApplicationContext ac = new ClassPathXmlApplicationContex\nt("applicationContext.xml");\n获取对象:\nUsersController uController = (UsersController)ac.get\nBean("uController");\n调用方法:\nint zch = uController.insert(new Users(1, "zch", 13));\n')])])]),e("h4",{attrs:{id:"基于注解的ioc-di"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于注解的ioc-di"}},[t._v("#")]),t._v(" 基于注解的IOC  > DI")]),t._v(" "),e("p",[t._v("IOC思想的具体实现的技术")]),t._v(" "),e("p",[t._v("必须在applicationContext.xml中添加包扫描,尽量具体，不要浪费时间")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<context:component-scan base-package="xyz.zch1337.dao,xyz.zch1337.pojo,xyz.zch1337.service.impl, xyz.zch1337.controller"></context:component-scan>\n')])])]),e("ol",[e("li",[e("p",[t._v("创建对象的注解")]),t._v(" "),e("p",[t._v('@Component:创建任意的对象，默认名称是类名的驼峰命名法,通过\n@Component("名字")来指定')]),t._v(" "),e("p",[t._v("@Controller:专于控制器的对象(Servlet)")]),t._v(" "),e("p",[t._v("@Service:业务逻辑层")]),t._v(" "),e("p",[t._v("@Repository:数据访问层")])]),t._v(" "),e("li",[e("p",[t._v("依赖注入的注解")]),t._v(" "),e("p",[t._v("值类型注入")]),t._v(" "),e("p",[t._v("@Value:")]),t._v(" "),e("p",[t._v("引用类型注入")]),t._v(" "),e("p",[t._v("@AutoWired 使用类型注入")]),t._v(" "),e("p",[t._v("@AutoWired@Qualifier使用名称注入")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Autowired@Qualifier("school")\n')])])])])]),t._v(" "),e("h4",{attrs:{id:"为应用指定多个spring配置文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为应用指定多个spring配置文件"}},[t._v("#")]),t._v(" 为应用指定多个Spring配置文件")]),t._v(" "),e("p",[t._v("拆分配置文件")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("按层拆")]),t._v(" "),e("p",[e("img",{attrs:{src:"C:%5CUsers%5CZhuChengHao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220731153441429.png",alt:"image-20220731153441429"}})])]),t._v(" "),e("li",[e("p",[t._v("按功能拆")])])]),t._v(" "),e("h4",{attrs:{id:"spring配置文件的整合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring配置文件的整合"}},[t._v("#")]),t._v(" Spring配置文件的整合")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('在total.xml文件中\n<import resource="applicationContext_*.xml"></import>\n测试读这个文件就可以了\n')])])]),e("h3",{attrs:{id:"面向切面编程aop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向切面编程aop"}},[t._v("#")]),t._v(" 面向切面编程AOP")]),t._v(" "),e("p",[t._v("切面:公共的功能")]),t._v(" "),e("p",[t._v("AOP:将切面单独开发")]),t._v(" "),e("h4",{attrs:{id:"手写aop框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手写aop框架"}},[t._v("#")]),t._v(" 手写AOP框架")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("代码文件地址:D:\\zhuchenghao\\04-Code\\02-Java\\03Main\\06-Spring\\springall\\spring_05_aop\n")])])]),e("h4",{attrs:{id:"spring支持的aop实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring支持的aop实现"}},[t._v("#")]),t._v(" Spring支持的AOP实现")]),t._v(" "),e("p",[t._v("Before、After、Throws、Around")]),t._v(" "),e("h4",{attrs:{id:"aop常用的术语"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop常用的术语"}},[t._v("#")]),t._v(" AOP常用的术语")]),t._v(" "),e("ul",[e("li",[t._v("切面:通用的功能")]),t._v(" "),e("li",[t._v("连接点:目标方法")]),t._v(" "),e("li",[t._v("切入点(Pointcut):多个连接点构成切入点")]),t._v(" "),e("li",[t._v("目标对象:被操作的对象")]),t._v(" "),e("li",[t._v("通知(Advice):指定切入的时机")])]),t._v(" "),e("h4",{attrs:{id:"aspectj框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aspectj框架"}},[t._v("#")]),t._v(" AspectJ框架")]),t._v(" "),e("p",[t._v("是一个java语言的面向切面的框架，提供切面实现")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("通知")]),t._v(" "),e("p",[t._v("@Before:可以得到目标方法的签名")]),t._v(" "),e("p",[t._v("@AfterReturning")]),t._v(" "),e("p",[t._v("@Around")]),t._v(" "),e("p",[t._v("@After")])]),t._v(" "),e("li",[e("p",[t._v("切入点表达式 重点")]),t._v(" "),e("p",[t._v("execution(访问权限 方法返回值 方法声明(参数) 异常类型)")]),t._v(" "),e("p",[t._v("简化 execution(方法返回值 方法声明(参数))")]),t._v(" "),e("p",[t._v("用到的符号:")]),t._v(" "),e("ul",[e("li")]),t._v(" "),e("p",[t._v(".. 如果出现在方法的参数中，代表任意参数")]),t._v(" "),e("p",[t._v(".. 如果出现在路径中，代表本路径及其所以子路径")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("eg: 重点\n\texecution(public *  *(..))  任意的公共方法\n\texecution(*  set*(..))   任何一个以set开始的方法\n\texecution(* com.xyz.service.impl.*.*(..)) 任意的放回值类型，在com.xyz.service.impl中任意类的任意方法\n\texecution(* com.xyz.service..*.*(..))) 任意的放回值类型,在com.xyz.service路径及其所以子路径中任意类的任意方法\n\texecution(* *..service.*.*(..)) service之前可以用任意的包\n\texecution(* *.service.*.*(..)) service之前只能有一个包\n")])])])]),t._v(" "),e("li",[e("p",[t._v("使用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!--绑定--\x3e\n<aop:aspectj-autoproxy proxy-target-class="false"></aop:aspectj-autoproxy>\n\n@Aspect@Component("myaspect1")\npublic class MyAspect {\n    @Before(value = "execution(public String xyz.zch1337.SomeServiceImpl.*(String, int))")\n    public void myBefore() {\n        System.out.println("前置功能实现");\n    }\n}\n\n')])])])]),t._v(" "),e("li",[e("p",[t._v("各种通知规范")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Before\n访问权限是public\n方法的返回值是void\n方法名称自定义\n方法没有参数，如果有只能是JoinPoint类型\n参数value\n可以得到目标方法的签名jp.getSignature()和参数jp.getArgs()\n\n@Aspect@Component("myaspect1")\npublic class MyAspect {\n    @Before(value = "execution(public String xyz.zch1337.SomeServiceImpl.*(String, int))")\n    public void myBefore(JoinPoint jp) {\n        System.out.println("前置功能实现");\n        System.out.println("@Before可以通过jp.getSignature()得到目标方法的签名" + jp.getSignature());\n        System.out.println("@Before可以通过jp.getArgs()得到目标方法的参数" + Arrays.toString(jp.getArgs()));\n    }\n}\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@AfterReturning\n规范:\n\t访问权限是public\n\t方法没有返回值void\n\t方法名自定义\n\t方法有参数\n\t使用@AfterReturning注解\n\t参数:\n\t\tvalue:切入点表达式\n\t\treturning:指定目标方法的返回值的名称，且名称必须与切\t\t   面方法的参数名称一致\n\t实现的功能:\n\t\t改变目标方法的返回值\n代码实现:\n    @AfterReturning(value = "execution(public * xyz.zch1337.SomeServiceImpl.*(..))", \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturning = "object")\n    public void myAfter(Object object) {\n        System.out.println("后置功能实现");\n        if (object != null) {\n            if (object instanceof String) {\n                object = object.toString();\n            }\n//            在切面方法中改变目标方法的返回值\n            if (object instanceof Student) {\n                object = new Student("李四").toString();\n            }\n        }\n        System.out.println("获取目标方法的返回值:" + object);\n    }\n\t\t\t\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Around环绕通知\n通过拦截目标方法的方式，在目标方法前后增强功能的通过。\n可以轻易的改变目标方法的返回值内容。\n规范:\n\t访问权限是public\n\t切面方法有返回值，该返回值就是目标方法的返回值\n\t方法名称自定义\n\t方法有参数，就是目标方法的参数\n\t必须回避异常\n    @Around(value = "execution(* xyz.zch1337.SomeServiceImpl.*(..))")\n    public Object myAround1(ProceedingJoinPoint pjp) throws Throwable {\n        //前切功能实现\n        System.out.println("myAround1前切功能实现");\n        //目标方法调用\n        Object obj = pjp.proceed(pjp.getArgs());\n        //后切功能实现\n        System.out.println("myAround1后切功能实现");\n        return obj.toString().toUpperCase(Locale.ROOT);\n    }\t\n')])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@After最终通知\n规范:\n\tpublic\n\tvoid\n\t名称自定义\n\t方法无参数，如果有只能是JoinPoint\n@After(value = "execution(* xyz.zch1337.SomeServiceImpl.doSome2(..))")\n    public void myAfter() {\n        //After功能实现\n        System.out.println("After功能实现");\n    }\n')])])])])]),t._v(" "),e("h5",{attrs:{id:"切入点表达式起别名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#切入点表达式起别名"}},[t._v("#")]),t._v(" 切入点表达式起别名")]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('    @After(value = "mycut()")    //这里调用别名的方法\n    public void myAfter() {\n        //After功能实现\n        System.out.println("After功能实现");\n    }\n    @Pointcut(value = "execution(* xyz.zch1337.SomeServiceImpl.*(..))")\n    public void mycut() {}\n')])])]),e("h3",{attrs:{id:"事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),e("ul",[e("li",[t._v("注解式事务")])]),t._v(" "),e("p",[t._v("​\t\t\t\t在applicationContext_service.xml中添加配置")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('        \x3c!--1.添加事务管理器--\x3e\n        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n            \x3c!--配置数据源 因为事务必须关联数据库处理--\x3e\n            <property name="dataSource" ref="dataSource"></property>\n        </bean>\n        \x3c!--2.添加事务的注解驱动--\x3e\n        <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>\n')])])]),e("p",[t._v("​\t\t\t 在AccountsServiceImpl中添加注解@Transactional")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('@Transactional(propagation = Propagation.REQUIRED,\nnoRollbackForClassName = "ArithmeticException")\n\npropagation = Propagation.REQUIRED 事务的传播特性\nnoRollbackForClassName = "ArithmeticException"  多个为{"", ""} 指定什么异常不回滚，使用的是异常的名称\nnoRollbackFor = ArithmeticException.class 使用的是异常的类名\nrollbackForClassName = "" 指定发生什么异常必须回滚\nrollbackFor = ArithmeticException.class,\ntimeout = -1 连接超时设置，默认值为-1，为永不超时\nreadOnly = false 默认是false，如果是查询操作，必须设置为true\nisolation = Isolation.DEFAULT 使用数据库的自己的隔离级别\n')])])]),e("ul",[e("li",[e("p",[t._v("声明式事务(重点)")]),t._v(" "),e("p",[t._v("在配置文件中添加一次，整个项目遵循事务的设定")]),t._v(" "),e("p",[t._v("数据库的隔离级别:")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("未提交读 Read Uncommitted")])]),t._v(" "),e("li",[e("p",[t._v("提交读 Read Committed")])]),t._v(" "),e("li",[e("p",[t._v("可重复读 Repeated Read")])]),t._v(" "),e("li",[e("p",[t._v("串行读 Serializable")])]),t._v(" "),e("li",[e("p",[t._v("默认的 isolation = Isolation.DEFAULT")]),t._v(" "),e("p",[t._v("mysql：可重复度")]),t._v(" "),e("p",[t._v("oracle：读已提交")])])]),t._v(" "),e("p",[t._v("​\t方法命名规范")]),t._v(" "),e("ol",[e("li",[t._v("​\t增加 add save insert set")]),t._v(" "),e("li",[t._v("​    更新 update change modify")]),t._v(" "),e("li",[t._v("​    删除 delete drop remove clear")]),t._v(" "),e("li",[t._v("​    查询 select find search get")])]),t._v(" "),e("p",[t._v("​\t配置事务切面是可以使用通配符来匹配所有的")])]),t._v(" "),e("li",[e("p",[t._v("为什么添加事务管理器")]),t._v(" "),e("p",[t._v("不同框架的提交事务和回滚方法不同，事务管理器用来生成响应技术的连接+执行语句的对象。")]),t._v(" "),e("p",[t._v("如果使用Mybatis框架，要在applicationContext_service.xml这么用")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\x3c!--1.添加事务管理器--\x3e\n        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n            \x3c!--配置数据源 因为事务必须关联数据库处理--\x3e\n            <property name="dataSource" ref="dataSource"></property>\n        </bean>\n        \x3c!--2.添加事务的注解驱动--\x3e\n        <tx:annotation-driven transaction-manager="transactionManager"></tx:annotation-driven>\n')])])])]),t._v(" "),e("li",[e("p",[t._v("spring事务的传播特性")]),t._v(" "),e("p",[t._v("​\tPropagation.REQUIRED 必备包含事务")]),t._v(" "),e("p",[t._v("​\tPropagation.REQUIRES_NEW 自己新开事务")]),t._v(" "),e("p",[t._v("​\tPropagation.SUPPORTS 支持事务，之前有事务，支持。如果没有，不单开事务")]),t._v(" "),e("p",[t._v("​\tPropagation.NEVER 不能运行在事务中，如果在，则抛异常")]),t._v(" "),e("p",[t._v("​\tPropagation.NOT_SUPPORTED 不支持事务，运行在非事务的环境")]),t._v(" "),e("p",[t._v("​\tPropagation.MANDATORY 必须包在事务内，否则抛异常")]),t._v(" "),e("p",[t._v("​\tPropagation.NESTED 嵌套事务")]),t._v(" "),e("p",[t._v("​\t"),e("img",{attrs:{src:"C:%5CUsers%5CZhuChengHao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220816221611369.png",alt:"image-20220816221611369"}})])])]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("h2",{attrs:{id:"sm整合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sm整合"}},[t._v("#")]),t._v(" SM整合")]),t._v(" "),e("h3",{attrs:{id:"步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[t._v("#")]),t._v(" 步骤")]),t._v(" "),e("ol",[e("li",[t._v("建数据库表")]),t._v(" "),e("li",[t._v("新建项目，选择quickstart模板")]),t._v(" "),e("li",[t._v("修改目录")]),t._v(" "),e("li",[t._v("修改pom.xml文件，添加相关的依赖")]),t._v(" "),e("li",[t._v("添加Mybatis相应的模板(SqlMapConfig.xml和XXXMapper.xml文件)")]),t._v(" "),e("li",[t._v("添加sqlMapConfig.xml文件(Mybatis核心配置文件)")]),t._v(" "),e("li",[t._v("添加applicationContext_mapper.xml")]),t._v(" "),e("li",[t._v("添加applicationContext_service.xml")]),t._v(" "),e("li",[t._v("添加Users实体类,Account实体类")]),t._v(" "),e("li",[t._v("添加mapper包，添加UsersMapper接口和UsersMapper.xml文件并开发")]),t._v(" "),e("li",[t._v("添加service包，添加UsersService接口和UserServiceImpl实现类")]),t._v(" "),e("li",[t._v("添加测试类进行功能测试")])])])}),[],!1,null,null,null);e.default=r.exports}}]);